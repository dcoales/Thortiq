# Section 6 Multiple Panes Implementation Plan

1. **Audit current outline + pane infrastructure**
   - Inspect shared outline store in `packages/client-core/src/outlineStore` to understand how a single pane is tracked today and how TanStack Virtual is wired (rules 7, 23, 33).
   - Catalogue editor mount logic in `packages/client-react`/`packages/client-desktop` to ensure only one ProseMirror instance stays active across panes (rule 20) and that adapters are thin wrappers over shared logic (rule 13).
   - Verify undo/redo plumbing (UndoManager wiring, `withTransaction` helpers) so pane operations can hook into the existing unified history (rules 3, 6, 29).
   - Findings: `SessionState` already persists a `panes` array with `activePaneId` and per-pane focus/search metadata, but only the default `"outline"` pane is ever instantiated and there are no helpers to add/remove entries yet (`packages/client-core/src/outlineStore/store.ts:591`, `packages/sync-core/src/sessionStore/state.ts:79`). `OutlineView` accepts a `paneId` and drives TanStack Virtual through `OutlineVirtualList`, so duplicating the component would give each pane its own virtualizer instance, yet the current shell only mounts one view (`apps/web/src/auth/AuthenticatedApp.tsx:422`, `apps/web/src/outline/OutlineView.tsx:1965`). `ActiveNodeEditor` always mounts whenever a pane renders and will spawn an independent ProseMirror view per pane, so we must refactor to keep a single shared editor when introducing additional panes (`apps/web/src/outline/OutlineView.tsx:1952`, `apps/web/src/outline/ActiveNodeEditor.tsx:256`). Undo/redo remains centralised through `SyncManager.undoManager`, and outline mutations flow through `outline-commands` utilities that wrap `withTransaction`, so structural operations invoked from new pane actions will automatically share history (e.g. `packages/client-core/src/sync/SyncManager.ts:141`, `packages/outline-commands/src/index.ts`).

2. **Define shared pane state model**
   - Add a `PaneState` interface and normalized storage (e.g. `Map<paneId, PaneState>`, ordered `paneIds`) in `packages/client-core` so panes have stable ULIDs and metadata such as `focusEdgeId`, `scrollOffset`, and `searchState` (rules 11, 15, 33).
   - Extend outline store actions to manage pane lifecycle (`openPane`, `closePane`, `activatePane`, `updatePaneFocus`) while keeping mutations inside `withTransaction(outline, ...)` where the outline graph changes (rules 2, 3, 29).
   - Ensure the unified UndoManager captures structural edits but skips pure UI state (e.g. active pane) to avoid polluting history; add brief comments to clarify this boundary (rules 2, 6).
   - Findings: session persistence still models panes as a positional array with inline metadata (`packages/sync-core/src/sessionStore/state.ts:31`, `packages/sync-core/src/sessionStore/state.ts:79`), and higher-level consumers search that array on every read (`packages/client-react/src/outline/OutlineProvider.tsx:120`, `packages/client-core/src/outlineStore/store.ts:591`). This shape makes it awkward to attach per-pane runtime data (scroll offsets, layout hints) and forces `findIndex` scans on each mutation (`packages/client-core/src/outlineStore/store.ts:103`). Normalising to `{ paneOrder: string[]; panesById: Map<string, PaneState> }` keeps ordering explicit while giving O(1) lookups.
   - Implementation outline:
     1. Introduce `PaneState` / `PaneViewState` types under `packages/client-core/src/panes/paneTypes.ts` describing persistent metadata (focus/search/collapsed history) versus transient UI data (scroll offset, preferredWidth). Keep the persistent subset aligned with `SessionPaneState` to simplify migrations.
     2. Revise `SESSION_VERSION` to 5 and update `defaultSessionState` plus cloning helpers to emit `{ paneOrder, panesById }` instead of the positional array (`packages/sync-core/src/sessionStore/state.ts`). Extend `normaliseCurrentVersionState` and legacy migrations in `packages/sync-core/src/sessionStore/persistence.ts` to collapse existing arrays into the new structure while preserving order.
     3. Update session commands (`packages/sync-core/src/sessionStore/commands.ts`) and reconciliation logic (`packages/sync-core/src/sessionStore/reconciliation.ts`) to target maps: replace `findPaneIndex` loops with direct map reads, adjust focus history writers to mutate by id, and keep helper utilities that still need ordered iteration working from `paneOrder`.
     4. Expose derived selectors in `packages/client-core/src/outlineStore/store.ts` that surface both the ordered list and map so React hooks can read pane ids without re-normalising every render. Replace `state.panes.find(...)` calls with map reads and feed the map into forthcoming lifecycle helpers (`openPane`, `closePane`, `updatePaneFocus`, `setActivePane`).
     5. Add bridging helpers that synchronise transient pane UI state held in the outline store (scroll positions, gutter widths) without serialising it into UndoManager history. Document the boundary with concise comments around the session updates that must *not* sit inside `withTransaction` to keep history clean.

3. **Implement pane opening commands**
   - Ctrl-click wikilink: update link handlers in `packages/client-react/src/outline` to detect modifier keys, resolve target node via shared navigation helpers, and call `openPaneRightOf(activePaneId, targetEdgeId)` (rules 8, 34).
   - Ctrl-click bullet: reuse the same action but resolve the clicked edge from virtualization row metadata, ensuring no DOM surgery occurs while typing (rules 4, 23, 34).
   - Shift-click wikilink/bullet: if a right-hand neighbor exists, call `updatePaneFocus(neighborPaneId, targetEdgeId)`; otherwise fall back to `openPaneRightOf` (rules 6, 26).
   - `Ctrl+N`: register the shortcut (web + desktop adapters) to create a sibling node inside a `withTransaction` block, then open the resulting pane with focus/caret at the new node’s start (rules 3, 24, 34). Guard for missing focus node by inserting at root in a single transaction.
   - Findings: Wiki link clicks already bubble an event object through `packages/client-react/src/outline/components/OutlineRowView.tsx:321-345`, but the React adapter ignores modifier keys (`apps/web/src/outline/OutlineView.tsx:1820-1823`). Bullet clicks, however, stop at the row component (`OutlineRowView.tsx:781-794`) so we need a new callback to surface the originating mouse event. Global shortcuts are currently handled via window listeners for Alt-based commands (`OutlineView.tsx:1181-1278`), so we must extend that infrastructure to distinguish `Ctrl/Cmd+N` without colliding with the existing quick note shortcut (`Alt+N`).
   - Implementation outline:
     1. Extend `OutlineRowView` with an `onBulletActivate` prop that receives the edge id plus the click event, and forward modifier-aware wiki link events unchanged. Update the component to call `onBulletActivate` from `handleBulletClick` before invoking the legacy focus path so the adapter can override behaviour (rule 34). Ensure we preserve existing preventDefault/stopPropagation semantics to avoid DOM surgery during typing (rules 4, 20).
     2. Introduce a pane-navigation helper (e.g. `packages/client-core/src/panes/paneCommands.ts`) that exposes `openPaneRightOf`, `focusPane`, and `ensureNeighborPane` utilities against the normalised `{ paneOrder, panesById }` structure from Step 2. These helpers should return reducers that the session store can apply without touching UndoManager (rules 2, 6) and accept options for initial focus edge ids.
     3. In `apps/web/src/outline/OutlineView.tsx`, swap the inline wiki link handler for a dedicated `handleWikiLinkActivate` that inspects `event.ctrlKey || event.metaKey` and `event.shiftKey`. For Ctrl/Cmd, call `openPaneRightOf` with the target edge, mark the new pane active, and clear search in the originating pane. For Shift, first attempt to focus the immediate right-hand pane via `ensureNeighborPane`; if missing, create one. Fall back to the existing `handleWikiLinkNavigate` when no modifiers are present.
     4. Wire `onBulletActivate` to a sibling handler that mirrors the wiki link logic but uses the clicked row’s `edgeId`. When a pane is opened via bullet modifiers, ensure we don’t re-run collapse toggles or selection mutations until after the transaction completes to keep virtualization stable (rules 23, 29).
     5. Add a new window keydown listener for `Ctrl/Cmd+N` beside the existing Alt shortcuts. Determine the insertion point by reading the current pane state (`pane.rootEdgeId` from `useOutlinePaneState`). Use outline commands (`insertSiblingBelow`, `addEdge`) inside a `withTransaction` block to create the new node, then call `openPaneRightOf` with the resulting edge id and move the shared editor/caret to the start of the new node (rules 3, 24, 34). If no focus node exists, create the node at the root level before opening the pane.
     6. Cover shared logic in a reusable hook (e.g. `usePaneOpener`) that lives in `packages/client-react/src/outline` so desktop/web adapters can share modifier handling and shortcut registration, keeping platform differences isolated to configuration (rules 8, 13).

4. **Pane layout & responsiveness**
   - Build a shared `PaneManager` component/hook in `packages/client-react` that renders panes based on the ordered pane list, manages the active indicator, and hides the close icon when only one pane remains (rule 35 for pointer interactions, rule 36 for focus).
   - Implement resizable gutters using an existing draggable utility or lightweight adapter, storing width percentages per pane in UI state (no UndoManager involvement). Debounce persistence to avoid performance hits (rules 2, 30).
   - For small screens, switch to a stacked layout with a pane switcher list; ensure virtualization instances mount/unmount cleanly to prevent memory leaks (rules 31, 32).
   - Findings: The web shell always renders a single `<OutlineView>` inside `apps/web/src/auth/AuthenticatedApp.tsx:421-423`, and `OutlineView` itself assumes full-viewport ownership (`styles.shell.height = 100vh`, padding baked in at lines `2102-2115`). To support multiple panes we need a parent layout that owns sizing while each pane flexes vertically. TanStack virtualisation is already encapsulated in `OutlineVirtualList`, exposing `onVirtualizerChange` so we can trigger re-measurement after gutter drags (`packages/client-react/src/outline/OutlineVirtualList.tsx:38-87`).
   - Implementation outline:
     1. Create `packages/client-react/src/outline/PaneManager.tsx` that consumes `useOutlinePaneIds`, `useOutlineActivePaneId`, and the pane runtime map from Step 2. Large screens render panes in a horizontal flex container with CSS grid/flex gap gutters; small screens render a stacked layout showing only the active pane with a switcher list (tabs or dropdown) for other panes. Keep DOM order aligned with `paneOrder` so mirrors remain predictable.
     2. Introduce `PaneRuntimeState` in `packages/client-core/src/panes/paneRuntime.ts` holding transient per-pane UI (width ratio, scrollOffset, mountedVirtualizer?). Persist widths in a lightweight in-memory store (not the UndoManager/session doc) and expose setters via the outline store so adapters can share logic across platforms (rules 2, 13).
     3. Refactor `OutlineView` so its root element no longer enforces `height: 100vh`/global padding; accept `style`/`className` overrides so the manager controls spacing. Move pane-specific chrome (active indicator bar, close button slot) into wrapper components rather than baking them into `OutlineView` to keep responsibilities separate (rules 8, 15).
     4. Implement draggable gutters in the manager using pointer events on dedicated divider elements. Enforce a sensible minimum width (e.g. 320 px) and update `PaneRuntimeState` on drag end. After width changes, call each pane’s registered `Virtualizer.measure()` via the `onVirtualizerChange` hook to keep TanStack caches accurate (rules 7, 23, 30).
     5. Maintain independent scroll areas per pane by forwarding a stable `scrollParentRef` to every `OutlineView`. When panes are hidden in stacked mode, unmount inactive panes to reduce editor/virtualizer overhead, but keep their runtime metadata (scroll position, width) cached so reactivation restores state (rules 31, 32, 36).
     6. Update the web adapter (`apps/web/src/auth/AuthenticatedApp.tsx`) to render the new `PaneManager` instead of a single `OutlineView`, wiring sidebar layout so the manager fills the remaining horizontal space. Provide the same API for the desktop shell once we add panes there to honour shared-first architecture (rule 13).

5. **Per-pane header behaviour**
   - Ensure each pane renders its own breadcrumb, navigation arrows, and search box instance wired to pane-scoped search state so queries do not leak across panes (rules 10, 22).
   - Add the close icon to headers when multiple panes exist; closing should reassign focus to the nearest surviving pane and dispose observers tied to the removed pane (rules 32, 36).
   - Keep the active-pane indicator (solid blue underline) in shared styling assets to avoid divergence between platforms (rules 13, 22).

6. **Caret, scroll, and editor management**
   - When activating or opening panes, switch the shared editor instance to the target node via existing `editor.setNode` APIs, maintaining seamless text parity (rules 20–22).
   - Store and restore scroll offsets per pane in lightweight state to avoid jarring jumps during pane switches; debounce writes to prevent thrashing (rules 30, 36).
   - Validate TanStack Virtual measurements remain accurate when panes open/close by invalidating caches on pane mount/unmount and after search-mode toggles (rules 7, 23).

7. **Closing panes and edge cases**
   - Prevent closing the last remaining pane; surface disabled state in the close button logic while keeping DOM structure stable (rules 4, 37).
   - When closing a pane, reassign active status to the nearest left pane (or right if none left) and clean up any pending async effects (rules 32, 36).
   - Ensure mirrors and CRDT edges remain untouched by pane operations—only view state changes should occur unless explicitly editing nodes (rules 5, 26).

8. **Testing & validation**
   - Add unit tests in `packages/client-core` covering pane state reducers/actions, ensuring transactions only wrap structural updates (rule 16).
   - Extend integration tests (web) to simulate ctrl/shift clicks, gutter resizing, mobile stacked layout, and undo/redo flows across panes (rules 16, 19, 24).
   - For desktop adapter, add smoke tests ensuring shortcuts and layout parity hold (rule 22). Document manual QA steps for responsive layouts and multi-pane search.
   - Before shipping, run `npm run lint && npm run typecheck && npm test` and capture results in task notes (rule 1).

9. **Documentation & follow-up**
   - Update `docs/thortiq_spec.md` references or cross-link this plan once work is complete; add any new architectural interfaces to `docs/architecture` (rules 14, 18).
   - Record verification outcomes under `docs/verification` (if that practice is still active) to help future agents confirm behaviour (rule 39).
   - Identify future enhancements (e.g., pane presets, synced scrolling) but defer implementation outside this scope to keep changes incremental (rule 39).
